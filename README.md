# qcoin - Quantum Coin Toss

A quantum-based binary choice maker that performs coin tosses using quantum random number generators. The application tries multiple quantum sources and uses a mix of cryptographically secure RNGs seeded with the quantum bytes obtained from a publicly available QRNG.

## Installation
You can build the project from source or install it directly from [crates.io](https://crates.io/crates/qcoin).

```bash
cargo install qcoin
```

## Usage

```bash
qcoin                           # Single coin flip
qcoin -n 10                     # 10 coin flips
qcoin --number 100              # 100 coin flips
qcoin -s entropy.hex            # Use hex string from entropy.hex as entropy source
qcoin --hex "abc123"            # Use hex string directly as entropy source
qcoin --hex "0xff"              # Use hex string with 0x prefix
qcoin -n 5 --hex "abc123"       # 5 flips using hex string
qcoin --hex "ff" -o saved.hex   # Use hex and save to custom file
```

### Example Source Files

**Hex String File (entropy.hex)**:
```
abc1234567890def
```

**Hex String with 0x prefix (entropy_prefixed.hex)**:
```
0xabc1234567890def
```

**Simple Hex File (always_yes.hex)**:
```
0xff
```

**Note**: Running `qcoin` in quick succession may fail due to API rate limits. If this happens, please wait and try again later. In the meantime, `qcoin` will reuse the quantum bytes saved in `qrandom.bytes` from a previous successful request.

### Command Line Options

| Flag | Description | Default | Notes |
|------|-------------|---------|-------|
| `-n, --number <flips>` | Number of coin flips | `1` | Must be greater than 0 |
| `-o, --output <file>` | Output file for quantum entropy | `qrandom.bytes` | Saves quantum or hex entropy |
| `-s, --source <file>` | Use file as entropy source instead of quantum sources | None | Supports hex strings or binary data |
| `--hex <string>` | Use hex string directly as entropy source | None | Supports 0x prefix, can be saved with -o |

### Source File Behavior

The `-s/--source` flag supports two file formats:

**üî§ Hex String Files** (Recommended):
- Contains hexadecimal string (e.g., `abc123`, `0xabc123`, `ff00ff00`)
- Automatically detected and decoded to bytes
- Supports optional `0x` or `0X` prefix
- Example: File containing `0xff` ‚Üí 1 byte with value 255 ‚Üí 8 ones, 0 zeros ‚Üí YES

**üî¢ Binary Files**:
- Raw binary data or text files treated as raw bytes
- Each character becomes its ASCII byte value

**Flip Behavior**:

**For Single Flip (N=1)**:
- **Any file size**: Uses file bytes directly for interpretation (no CSRNG involved)
- Example: A 1-byte file with value `255` (binary: `11111111`) ‚Üí 8 ones, 0 zeros ‚Üí YES

**For Multiple Flips (N>1)**:
- **File size = 1024 bytes**: Uses file content directly (same as quantum entropy)
- **File size < 1024 bytes**: Uses file bytes to seed CSRNG for N-1 flips + uses file bytes directly for 1 flip
- **File size > 1024 bytes**: Uses file bytes to seed CSRNG for N-1 flips + uses file bytes directly for 1 flip

### Hex String Behavior

When using the `--hex` flag:

**For Single Flip (N=1)**:
- **Any hex length**: Uses hex bytes directly for interpretation (no CSRNG involved)
- Example: `--hex "ff"` ‚Üí 1 byte with value 255 ‚Üí 8 ones, 0 zeros ‚Üí YES

**For Multiple Flips (N>1)**:
- **Hex = 1024 bytes**: Uses hex bytes directly (same as quantum entropy)
- **Hex < 1024 bytes**: Uses hex bytes to seed CSRNG for N-1 flips + uses hex bytes directly for 1 flip
- **Hex > 1024 bytes**: Uses hex bytes to seed CSRNG for N-1 flips + uses hex bytes directly for 1 flip

**Note**: Hex entropy can be saved with `-o` for reuse, unlike source files which conflict with `-o`.

## How it Works

### Coin Flip Interpretation

The application interprets coin flips by counting 1-bits vs 0-bits in random bytes:

**üéØ Core Principle**: Each byte contains 8 bits. We count all the 1-bits and 0-bits across all bytes, then compare:
- **More 1-bits than 0-bits** ‚Üí Outcome: **YES** ‚úÖ
- **More 0-bits than 1-bits** ‚Üí Outcome: **NO** ‚ùå

**üìä Single Coin Flip (N=1)**:
- Uses the entropy bytes directly (quantum, source file, or fallback)
- No CSRNG involved - pure entropy interpretation
- Example: 1024 bytes = 8,192 bits total ‚Üí count 1s vs 0s

**üîÑ Multiple Coin Flips (N>1)**:
- **N-1 flips**: Generated using CSRNG seeded with the entropy bytes
- **1 flip**: Uses the original entropy bytes directly (no CSRNG)
- **Final result**: Count 1s vs 0s across ALL generated bytes combined

This hybrid approach ensures that:
- At least one flip always uses pure entropy (quantum or source file)
- Large numbers of flips are computationally efficient
- Results remain deterministic when using the same entropy source

### Entropy Source Priority

The application attempts to fetch truly random bytes from sources in this order:

1. **üî¨ [ANU QRNG](https://qrng.anu.edu.au/)** - Australian National University's Quantum Random Number Generator
2. **üåê [qrandom.io](https://qrandom.io/)** 
3. **üîí Cryptographic SRNG** - Cryptographically secure random number generator (fallback)
4. **‚ôªÔ∏è Saved Quantum Bytes** - Previously saved quantum entropy from `qrandom.bytes`

### Core Logic

The program implements a hybrid approach for multiple coin flips:

#### Single Flip (N=1)
- Uses quantum bytes directly to count 1s vs 0s
- Pure quantum randomness determines the outcome

#### Multiple Flips (N>1) 
- **N-1 flips**: Generated using a CSRNG seeded with quantum entropy
- **1 flip**: Uses the original quantum bytes directly
- **Parallel processing**: CSRNG flips are generated in parallel for performance

This approach ensures:
- At least one flip always uses pure quantum randomness
- Computational efficiency for large numbers of flips
- Deterministic results when using the same quantum seed

### Example Flow for 10 Flips (Quantum Sources)
1. Fetch 1024 quantum bytes from ANU QRNG
2. Save quantum bytes to `qrandom.bytes`
3. Generate 9 flips (9 √ó 1024 = 9,216 bytes) using quantum-seeded CSRNG
4. Use the original 1024 quantum bytes for the 10th flip
5. Count total 1s vs 0s across all 10,240 bytes
6. Determine outcome: more 1s = YES, more 0s = NO

### Example Flow for 10 Flips (Source File)
1. Read entropy bytes from specified source file
2. Generate 9 flips (9 √ó 1024 = 9,216 bytes) using file-seeded CSRNG
3. Use the original file bytes for the 10th flip
4. Count total 1s vs 0s across all generated bytes
5. Determine outcome: more 1s = YES, more 0s = NO

### Output
```
üé≤ Quantum Coin Toss

üìä Flips: 10

üîç Trying ANU QRNG...
‚úÖ ANU QRNG: 1024 bytes
üíæ Saved quantum entropy to file
üå± Using quantum seed for 10 flips (9 CSRNG + 1 quantum)
‚ö° Generating 9216 bytes from seeded CSRNG (9 flips)
‚úÖ Generated 9216 bytes from CSRNG
üî¨ Using quantum entropy directly for final flip

üìà Result: 40,960 ones, 40,944 zeros
üéØ Outcome: YES
```

## Dependencies

- `rand` - Cryptographic random number generation and seeding
- `reqwest` - HTTP client for quantum API requests  
- `serde` - JSON parsing for API responses
- `rayon` - Parallel processing for multiple flips
- `hex` - Hexadecimal encoding/decoding utilities
- `sha2` - SHA-2 cryptographic hash functions
